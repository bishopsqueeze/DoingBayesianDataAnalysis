flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.5 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.3 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.3 )
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
flipSequence
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
#------------------------------------------------------------------------------
# 180603 - Commenting the source code
#------------------------------------------------------------------------------
# Specify the total number of flips, denoted N.
N = 1000
# Specify underlying probability of heads.
pHeads = 0.5
# Flip a coin N times and compute the running proportion of heads at each flip.
# Generate a random sample of N flips (heads=1, tails=0):
flipSequence = sample( x=c(0,1), prob=c(1-pHeads, pHeads), size=N, replace=TRUE )
# Compute the running proportion of heads:
r = cumsum( flipSequence ) # Cumulative sum: Number of heads at each step.
n = 1:N                    # Number of flips at each step.
runProp = r / n            # Component by component division.
# Graph the running proportion:
plot( n , runProp , type="o" , log="x" , col="skyblue" ,
xlim=c(1,N) , ylim=c(0.0,1.0) , cex.axis=1.0 ,
xlab="Flip Number" , ylab="Proportion Heads" , cex.lab=1.0 ,
main="Running Proportion of Heads" , cex.main=1.5 )
# Plot a dotted horizontal reference line:
abline( h=pHeads , lty="dotted" )
# Display the beginning of the flip sequence:
flipLetters = paste( c("T","H")[flipSequence[1:10]+1] , collapse="" )
displayString = paste0( "Flip Sequence = " , flipLetters , "..." )
text( N , .9 , displayString , adj=c(1,0.5) , cex=1.0 )
# Display the relative frequency at the end of the sequence.
text( N , .8 , paste("End Proportion =",runProp[N]) , adj=c(1,0.5) , cex=1.0 )
show( HairEyeColor )
EyeHairFreq <- apply( HairEyeColor, c("Eye", "Hair"), sum)
EyeHairFreq
names(HairEyeColor)
class(HairEyeColor)
dim(HairEyeColor)
str(HairEyeColor)
EyeHairProp <- EyeHairFreq / sum(EyeHairFreq)
EyeHairProp
HairFreq <- apply( HairEyeColor, c("Hair"), sum)
HairFreq
# review the data - available in the R dist
show( HairEyeColor )
# sum across sex (we are leaving out sex in the apply)
EyeHairFreq <- apply( HairEyeColor, c("Eye", "Hair"), sum)
HairFreq <- apply( HairEyeColor, c("Hair"), sum)
# proportions
EyeHairProp <- EyeHairFreq / sum(EyeHairFreq)
HairProp <- HairFreq / sum(HairFreq)
HairProp
HairProp
# sum across sex (we are leaving out sex in the apply)
EyeHairFreq <- apply( HairEyeColor, c("Eye", "Hair"), sum)
HairFreq <- apply( HairEyeColor, c("Hair"), sum)
EyeFreq <- apply( HairEyeColor, c("Eye"), sum)
# proportions
EyeHairProp <- EyeHairFreq / sum(EyeHairFreq)
HairProp <- HairFreq / sum(HairFreq)
EyeProp <- EyeFreq / sum(EyeFreq)
EyeProp
sum(EyeProp)
EyeHairProp["Blue", ]
EyeHairProp
EyeHairProp["Blue", ] / EyeProp["Blue"]
sum(EyeHairProp["Blue", ])
sum(EyeHairProp["Blue", ] / EyeProp["Blue"])
sum(HairFreq)
sum(EyeFreq)
sum(EyeHairFreq)
prob.blueEye <- EyeHairProp["Blue", ] / EyeProp["Blue"]
prob.blueEye
prob.HairCondEyeBrown <- EyeHairProp["Brown", ] / EyeProp["Brown"]
prob.HairCondEyeBrown
prob.HairCondEyeBlue
prob.HairCondEyeBlue <- EyeHairProp["Blue", ] / EyeProp["Blue"]
prob.HairCondEyeBrown <- EyeHairProp["Brown", ] / EyeProp["Brown"]
prob.HairCondEyeBlue
EyeHairProp
prob.EyeCondHairBrown <- EyeHairProp[ , "Brown" ] / HairProp["Brown"]
prob.EyeCondHairBrown
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
source('~/Development/DoingBayesianDataAnalysis/Chapter04/RunningProportion.R')
# Graph of normal probability density function, with comb of intervals.
meanval = 0.0               # Specify mean of distribution.
sdval = 0.2                 # Specify standard deviation of distribution.
xlow  = meanval - 3.5*sdval # Specify low end of x-axis.
xhigh = meanval + 3.5*sdval # Specify high end of x-axis.
dx = sdval/10               # Specify interval width on x-axis
# Specify comb of points along the x axis:
x = seq( from = xlow , to = xhigh , by = dx )
# Compute y values, i.e., probability density at each value of x:
y = ( 1/(sdval*sqrt(2*pi)) ) * exp( -.5 * ((x-meanval)/sdval)^2 )
# Plot the function. "plot" draws the intervals. "lines" draws the bell curve.
#openGraph(width=7,height=5)
plot( x , y , type="h" , lwd=1 , cex.axis=1.5
, xlab="x" , ylab="p(x)" , cex.lab=1.5 ,
, main="Normal Probability Density" , cex.main=1.5 )
lines( x , y , lwd=3 ,  col="skyblue" )
# Approximate the integral as the sum of width * height for each interval.
area = sum( dx * y )
# Display info in the graph.
text( meanval-sdval , .9*max(y) , bquote( paste(mu ," = " ,.(meanval)) )
, adj=c(1,.5) , cex=1.5 )
text( meanval-sdval , .75*max(y) , bquote( paste(sigma ," = " ,.(sdval)) )
, adj=c(1,.5) , cex=1.5 )
text( meanval+sdval , .9*max(y) , bquote( paste(Delta , "x = " ,.(dx)) )
, adj=c(0,.5) , cex=1.5 )
text( meanval+sdval , .75*max(y) ,
bquote(
paste( sum(,x,) , " " , Delta , "x p(x) = " , .(signif(area,3)) )
) , adj=c(0,.5) , cex=1.5 )
# Graph of normal probability density function, with comb of intervals.
meanval = 0.0               # Specify mean of distribution.
sdval = 0.2                 # Specify standard deviation of distribution.
#xlow  = meanval - 3.5*sdval # Specify low end of x-axis.
#xhigh = meanval + 3.5*sdval # Specify high end of x-axis.
xlow  = 0 # Specify low end of x-axis.
xhigh = 1 # Specify high end of x-axis.
#dx = sdval/10               # Specify interval width on x-axis
dx = 0.01/10               # Specify interval width on x-axis
# Specify comb of points along the x axis:
x = seq( from = xlow , to = xhigh , by = dx )
x
dx = 0.05/10               # Specify interval width on x-axis
dx
# Specify comb of points along the x axis:
x = seq( from = xlow , to = xhigh , by = dx )
meanval = 0.0               # Specify mean of distribution.
sdval = 0.2                 # Specify standard deviation of distribution.
#xlow  = meanval - 3.5*sdval # Specify low end of x-axis.
#xhigh = meanval + 3.5*sdval # Specify high end of x-axis.
xlow  = 0 # Specify low end of x-axis.
xhigh = 1 # Specify high end of x-axis.
#dx = sdval/10               # Specify interval width on x-axis
dx = 0.05/10               # Specify interval width on x-axis
# Specify comb of points along the x axis:
x = seq( from = xlow , to = xhigh , by = dx )
# Compute y values, i.e., probability density at each value of x:
#y = ( 1/(sdval*sqrt(2*pi)) ) * exp( -.5 * ((x-meanval)/sdval)^2 )
y = ( 6*x*(1-x) )
# Plot the function. "plot" draws the intervals. "lines" draws the bell curve.
#openGraph(width=7,height=5)
plot( x , y , type="h" , lwd=1 , cex.axis=1.5
, xlab="x" , ylab="p(x)" , cex.lab=1.5 ,
, main="Normal Probability Density" , cex.main=1.5 )
lines( x , y , lwd=3 ,  col="skyblue" )
source('~/Development/DoingBayesianDataAnalysis/Chapter04/IntegralOfDensity.R')
# Graph of normal probability density function, with comb of intervals.
meanval = 0.0               # Specify mean of distribution.
sdval = 0.2                 # Specify standard deviation of distribution.
#xlow  = meanval - 3.5*sdval # Specify low end of x-axis.
#xhigh = meanval + 3.5*sdval # Specify high end of x-axis.
xlow  = 0 # Specify low end of x-axis.
xhigh = 1 # Specify high end of x-axis.
#dx = sdval/10               # Specify interval width on x-axis
dx = 0.01               # Specify interval width on x-axis
# Specify comb of points along the x axis:
x = seq( from = xlow , to = xhigh , by = dx )
# Compute y values, i.e., probability density at each value of x:
#y = ( 1/(sdval*sqrt(2*pi)) ) * exp( -.5 * ((x-meanval)/sdval)^2 )
y = ( 6*x*(1-x) )
# Plot the function. "plot" draws the intervals. "lines" draws the bell curve.
#openGraph(width=7,height=5)
plot( x , y , type="h" , lwd=1 , cex.axis=1.5
, xlab="x" , ylab="p(x)" , cex.lab=1.5 ,
, main="Normal Probability Density" , cex.main=1.5 )
lines( x , y , lwd=3 ,  col="skyblue" )
# Approximate the integral as the sum of width * height for each interval.
area = sum( dx * y )
area
# Plot the function. "plot" draws the intervals. "lines" draws the bell curve.
#openGraph(width=7,height=5)
plot( x , y , type="h" , lwd=1 , cex.axis=1.5
, xlab="x" , ylab="p(x)" , cex.lab=1.5 ,
, main="Probability Density = 6x*(1-x)" , cex.main=1.5 )
lines( x , y , lwd=3 ,  col="skyblue" )
# Approximate the integral as the sum of width * height for each interval.
area = sum( dx * y )
# Plot the function. "plot" draws the intervals. "lines" draws the bell curve.
#openGraph(width=7,height=5)
plot( x , y , type="h" , lwd=1 , cex.axis=1.5
, xlab="x" , ylab="p(x)" , cex.lab=1.5
, main="Probability Density = 6x*(1-x)" , cex.main=1.5 )
lines( x , y , lwd=3 ,  col="skyblue" )
0.3*0.2
0.6*0.2
0.6*3
00.06*3
(0.06*3)+(0.02*2)+(0.12*2)+0.18+0.36
